Question 1
page 0包含什么？
在RISC-V架构中，页表的第0页（通常是最顶层的页表）通常包含指向下一级页表的虚拟地址映射。根据虚拟内存的层次结构，page 0 可能会包含一些有效的页表项（PTE），指向物理内存中的页或其他页表。具体内容取决于您所映射的内容，比如代码段、数据段等。

page 2中是什么？
page 2 的内容通常取决于该页表的具体映射。在 vmprint 的输出中，page 2 对应的 PTE（页表项）将指向某个物理页面，这个物理页面可能存储程序的数据或代码。您需要查看 vmprint 输出中 page 2 的对应行，来确定它的物理地址（PA）和状态。

在用户模式下运行时，进程是否可以读取/写入page 1映射的内存？
在用户模式下，进程对内存的访问权限由PTE的权限位决定。如果 page 1 的 PTE 显示为可读写（即对应的权限位允许用户进程读写），那么该进程可以读取和写入 page 1 映射的内存。如果 PTE 显示为只读或没有用户访问权限，则该进程将在尝试写入时遇到访问错误。因此，您需要查看 page 1 的 PTE 状态来做出判断。

Question 2 
在 copyin_new() 函数中，第三个测试 srcva + len < srcva 的目的是为了防止整数溢出（integer overflow）。当 srcva 是一个较大的值且 len 是一个正数时，srcva + len 可能会导致溢出，从而产生一个小于 srcva 的结果。这种情况会导致访问无效的内存区域，从而引发未定义的行为或内存错误。

举例说明
假设 srcva 是一个较大的虚拟地址，例如 0xFFFFFFFFFFFFFFFF（这是一个64位地址空间的最大值），并假设 len 为 1。在进行 srcva + len 的计算时，结果将会溢出，变成：
srcva + len = 0xFFFFFFFFFFFFFFFF + 1 = 0x0000000000000000
此时，尽管 srcva 和 len 的值使得前两个测试（例如检查 srcva 是否有效、是否在用户地址空间内等）都为假（即没有返回-1），但是由于 srcva + len 的结果为 0，会导致第三个测试为真，从而返回 -1。

另一个例子是：
srcva = 0x7FFFFFFFFFFFFFFF（接近64位地址空间的上限）
len = 10（一个小的正整数）
计算结果为：
srcva + len = 0x7FFFFFFFFFFFFFFF + 10 = 0x8000000000000009
在这个例子中，srcva + len 产生的结果并不会小于 srcva，但如果 len 更大，可能会出现溢出。
